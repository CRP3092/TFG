{"ast":null,"code":"// utils/favorites.js\nimport config from \"./config\";\n\n// Función para actualizar los favoritos del usuario (agregar o quitar)\n// favoriteId: identificador del contenido (película o serie)\n// addFavorite: booleano indicando si se agrega (true) o se remueve (false)\nexport const updateFavorites = async (favoriteId, addFavorite) => {\n  const userStr = sessionStorage.getItem(\"user\");\n  if (!userStr) return false;\n  const user = JSON.parse(userStr);\n  let favs = [];\n  if (user.Favorites && user.Favorites.trim() !== \"\") {\n    favs = user.Favorites.split(\",\").map(fav => fav.trim());\n  }\n  if (addFavorite) {\n    if (!favs.includes(String(favoriteId))) {\n      favs.push(String(favoriteId));\n    }\n  } else {\n    favs = favs.filter(fav => fav !== String(favoriteId));\n  }\n\n  // Actualizamos la propiedad Favorites y guardamos el usuario actualizado\n  user.Favorites = favs.join(\",\");\n  sessionStorage.setItem(\"user\", JSON.stringify(user));\n\n  // Preparamos el objeto payload para notificar al backend\n  const payload = {\n    userId: user.Id_User,\n    // Asegúrate de que coincide con la propiedad en la BD (user_id)\n    itemId: String(favoriteId),\n    // Corresponde a item_key\n    isFavorite: addFavorite\n  };\n  try {\n    const response = await fetch(`${config.API_URL}/api/usuario/favorites`, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n    if (!response.ok) {\n      throw new Error(`Error actualizando favoritos (Código: ${response.status})`);\n    }\n    console.log(\"✅ Favoritos actualizados en el backend:\", await response.json());\n    return true;\n  } catch (error) {\n    console.error(\"❌ Error actualizando favoritos en el backend:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["config","updateFavorites","favoriteId","addFavorite","userStr","sessionStorage","getItem","user","JSON","parse","favs","Favorites","trim","split","map","fav","includes","String","push","filter","join","setItem","stringify","payload","userId","Id_User","itemId","isFavorite","response","fetch","API_URL","method","headers","body","ok","Error","status","console","log","json","error"],"sources":["C:/wamp64/www/BlockBuster/frontend/src/utils/favorites.js"],"sourcesContent":["// utils/favorites.js\r\nimport config from \"./config\";\r\n\r\n// Función para actualizar los favoritos del usuario (agregar o quitar)\r\n// favoriteId: identificador del contenido (película o serie)\r\n// addFavorite: booleano indicando si se agrega (true) o se remueve (false)\r\nexport const updateFavorites = async (favoriteId, addFavorite) => {\r\n  const userStr = sessionStorage.getItem(\"user\");\r\n  if (!userStr) return false;\r\n\r\n  const user = JSON.parse(userStr);\r\n  let favs = [];\r\n\r\n  if (user.Favorites && user.Favorites.trim() !== \"\") {\r\n    favs = user.Favorites.split(\",\").map(fav => fav.trim());\r\n  }\r\n\r\n  if (addFavorite) {\r\n    if (!favs.includes(String(favoriteId))) {\r\n      favs.push(String(favoriteId));\r\n    }\r\n  } else {\r\n    favs = favs.filter(fav => fav !== String(favoriteId));\r\n  }\r\n\r\n  // Actualizamos la propiedad Favorites y guardamos el usuario actualizado\r\n  user.Favorites = favs.join(\",\");\r\n  sessionStorage.setItem(\"user\", JSON.stringify(user));\r\n\r\n  // Preparamos el objeto payload para notificar al backend\r\n  const payload = {\r\n    userId: user.Id_User, // Asegúrate de que coincide con la propiedad en la BD (user_id)\r\n    itemId: String(favoriteId), // Corresponde a item_key\r\n    isFavorite: addFavorite,\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(`${config.API_URL}/api/usuario/favorites`, {\r\n      method: \"PUT\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(payload),\r\n    });\r\n    if (!response.ok) {\r\n      throw new Error(`Error actualizando favoritos (Código: ${response.status})`);\r\n    }\r\n    console.log(\"✅ Favoritos actualizados en el backend:\", await response.json());\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"❌ Error actualizando favoritos en el backend:\", error);\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"AAAA;AACA,OAAOA,MAAM,MAAM,UAAU;;AAE7B;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAG,MAAAA,CAAOC,UAAU,EAAEC,WAAW,KAAK;EAChE,MAAMC,OAAO,GAAGC,cAAc,CAACC,OAAO,CAAC,MAAM,CAAC;EAC9C,IAAI,CAACF,OAAO,EAAE,OAAO,KAAK;EAE1B,MAAMG,IAAI,GAAGC,IAAI,CAACC,KAAK,CAACL,OAAO,CAAC;EAChC,IAAIM,IAAI,GAAG,EAAE;EAEb,IAAIH,IAAI,CAACI,SAAS,IAAIJ,IAAI,CAACI,SAAS,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,EAAE;IAClDF,IAAI,GAAGH,IAAI,CAACI,SAAS,CAACE,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAACC,GAAG,IAAIA,GAAG,CAACH,IAAI,CAAC,CAAC,CAAC;EACzD;EAEA,IAAIT,WAAW,EAAE;IACf,IAAI,CAACO,IAAI,CAACM,QAAQ,CAACC,MAAM,CAACf,UAAU,CAAC,CAAC,EAAE;MACtCQ,IAAI,CAACQ,IAAI,CAACD,MAAM,CAACf,UAAU,CAAC,CAAC;IAC/B;EACF,CAAC,MAAM;IACLQ,IAAI,GAAGA,IAAI,CAACS,MAAM,CAACJ,GAAG,IAAIA,GAAG,KAAKE,MAAM,CAACf,UAAU,CAAC,CAAC;EACvD;;EAEA;EACAK,IAAI,CAACI,SAAS,GAAGD,IAAI,CAACU,IAAI,CAAC,GAAG,CAAC;EAC/Bf,cAAc,CAACgB,OAAO,CAAC,MAAM,EAAEb,IAAI,CAACc,SAAS,CAACf,IAAI,CAAC,CAAC;;EAEpD;EACA,MAAMgB,OAAO,GAAG;IACdC,MAAM,EAAEjB,IAAI,CAACkB,OAAO;IAAE;IACtBC,MAAM,EAAET,MAAM,CAACf,UAAU,CAAC;IAAE;IAC5ByB,UAAU,EAAExB;EACd,CAAC;EAED,IAAI;IACF,MAAMyB,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAG7B,MAAM,CAAC8B,OAAO,wBAAwB,EAAE;MACtEC,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE;QAAE,cAAc,EAAE;MAAmB,CAAC;MAC/CC,IAAI,EAAEzB,IAAI,CAACc,SAAS,CAACC,OAAO;IAC9B,CAAC,CAAC;IACF,IAAI,CAACK,QAAQ,CAACM,EAAE,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,yCAAyCP,QAAQ,CAACQ,MAAM,GAAG,CAAC;IAC9E;IACAC,OAAO,CAACC,GAAG,CAAC,yCAAyC,EAAE,MAAMV,QAAQ,CAACW,IAAI,CAAC,CAAC,CAAC;IAC7E,OAAO,IAAI;EACb,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdH,OAAO,CAACG,KAAK,CAAC,+CAA+C,EAAEA,KAAK,CAAC;IACrE,OAAO,KAAK;EACd;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
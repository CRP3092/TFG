{"ast":null,"code":"// utils/favorites.js\nimport config from \"./config\";\n\n// Función para actualizar los favoritos del usuario (agregar o quitar)\n// favoriteId: identificador del contenido (película o serie)\n// addFavorite: booleano indicando si se agrega (true) o se remueve (false)\nexport const updateFavorites = async (favoriteId, addFavorite) => {\n  const userStr = sessionStorage.getItem(\"user\");\n  if (!userStr) return false;\n  const user = JSON.parse(userStr);\n\n  // Aseguramos que la propiedad Favorites sea una cadena válida\n  let userFavs = user.Favorites;\n  if (!userFavs || userFavs === \"undefined\") {\n    userFavs = \"\";\n  }\n\n  // Convertimos la cadena en un array (si no está vacía)\n  let favs = [];\n  if (userFavs.trim() !== \"\") {\n    favs = userFavs.split(\",\").map(fav => fav.trim());\n  }\n\n  // Actualizamos el array según si se agrega o se retira el favorito\n  if (addFavorite) {\n    if (!favs.includes(String(favoriteId))) {\n      favs.push(String(favoriteId));\n    }\n  } else {\n    favs = favs.filter(fav => fav !== String(favoriteId));\n  }\n\n  // Actualizamos la propiedad Favorites y guardamos el usuario actualizado\n  user.Favorites = favs.join(\",\");\n  sessionStorage.setItem(\"user\", JSON.stringify(user));\n\n  // Preparamos el objeto payload para notificar al backend\n  const payload = {\n    userId: user.Id_User,\n    // Debe coincidir con la columna \"user_id\" en la BD\n    itemKey: String(favoriteId),\n    // Usamos \"itemKey\" en lugar de \"itemId\"\n    isFavorite: addFavorite\n  };\n  try {\n    const response = await fetch(`${config.API_URL}/api/usuario/favorites`, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(payload)\n    });\n    if (!response.ok) {\n      throw new Error(`Error actualizando favoritos (Código: ${response.status})`);\n    }\n    const backendData = await response.json();\n    console.log(\"✅ Favoritos actualizados en el backend:\", backendData);\n\n    // Opcional: Actualizamos el usuario desde el backend para tener siempre datos correctos\n    const updatedUserResponse = await fetch(`${config.API_URL}/api/usuario/${user.Id_User}`);\n    if (updatedUserResponse.ok) {\n      const updatedUserData = await updatedUserResponse.json();\n      sessionStorage.setItem(\"user\", JSON.stringify(updatedUserData));\n      window.dispatchEvent(new CustomEvent(\"favoritesUpdated\"));\n    }\n    return true;\n  } catch (error) {\n    console.error(\"❌ Error actualizando favoritos en el backend:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["config","updateFavorites","favoriteId","addFavorite","userStr","sessionStorage","getItem","user","JSON","parse","userFavs","Favorites","favs","trim","split","map","fav","includes","String","push","filter","join","setItem","stringify","payload","userId","Id_User","itemKey","isFavorite","response","fetch","API_URL","method","headers","body","ok","Error","status","backendData","json","console","log","updatedUserResponse","updatedUserData","window","dispatchEvent","CustomEvent","error"],"sources":["C:/wamp64/www/BlockBuster/frontend/src/utils/favorites.js"],"sourcesContent":["// utils/favorites.js\r\nimport config from \"./config\";\r\n\r\n// Función para actualizar los favoritos del usuario (agregar o quitar)\r\n// favoriteId: identificador del contenido (película o serie)\r\n// addFavorite: booleano indicando si se agrega (true) o se remueve (false)\r\nexport const updateFavorites = async (favoriteId, addFavorite) => {\r\n  const userStr = sessionStorage.getItem(\"user\");\r\n  if (!userStr) return false;\r\n\r\n  const user = JSON.parse(userStr);\r\n\r\n  // Aseguramos que la propiedad Favorites sea una cadena válida\r\n  let userFavs = user.Favorites;\r\n  if (!userFavs || userFavs === \"undefined\") {\r\n    userFavs = \"\";\r\n  }\r\n\r\n  // Convertimos la cadena en un array (si no está vacía)\r\n  let favs = [];\r\n  if (userFavs.trim() !== \"\") {\r\n    favs = userFavs.split(\",\").map(fav => fav.trim());\r\n  }\r\n\r\n  // Actualizamos el array según si se agrega o se retira el favorito\r\n  if (addFavorite) {\r\n    if (!favs.includes(String(favoriteId))) {\r\n      favs.push(String(favoriteId));\r\n    }\r\n  } else {\r\n    favs = favs.filter(fav => fav !== String(favoriteId));\r\n  }\r\n\r\n  // Actualizamos la propiedad Favorites y guardamos el usuario actualizado\r\n  user.Favorites = favs.join(\",\");\r\n  sessionStorage.setItem(\"user\", JSON.stringify(user));\r\n\r\n  // Preparamos el objeto payload para notificar al backend\r\n  const payload = {\r\n    userId: user.Id_User,        // Debe coincidir con la columna \"user_id\" en la BD\r\n    itemKey: String(favoriteId),   // Usamos \"itemKey\" en lugar de \"itemId\"\r\n    isFavorite: addFavorite,\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(`${config.API_URL}/api/usuario/favorites`, {\r\n      method: \"PUT\",\r\n      headers: { \"Content-Type\": \"application/json\" },\r\n      body: JSON.stringify(payload),\r\n    });\r\n    if (!response.ok) {\r\n      throw new Error(`Error actualizando favoritos (Código: ${response.status})`);\r\n    }\r\n    const backendData = await response.json();\r\n    console.log(\"✅ Favoritos actualizados en el backend:\", backendData);\r\n\r\n    // Opcional: Actualizamos el usuario desde el backend para tener siempre datos correctos\r\n    const updatedUserResponse = await fetch(`${config.API_URL}/api/usuario/${user.Id_User}`);\r\n    if (updatedUserResponse.ok) {\r\n      const updatedUserData = await updatedUserResponse.json();\r\n      sessionStorage.setItem(\"user\", JSON.stringify(updatedUserData));\r\n      window.dispatchEvent(new CustomEvent(\"favoritesUpdated\"));\r\n    }\r\n    return true;\r\n  } catch (error) {\r\n    console.error(\"❌ Error actualizando favoritos en el backend:\", error);\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}